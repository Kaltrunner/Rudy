import { EuropaOptions } from "./EuropaOptions";
import { Environment } from "./environment/Environment";
import { PluginProvider } from "./plugin/Plugin";
import { PresetProvider } from "./plugin/Preset";
declare const _environment: unique symbol;
declare const _options: unique symbol;
declare const _pluginManager: unique symbol;
/**
 * A transformer capable of converting HTML into Markdown that supports HTML strings and DOM elements and nodes.
 */
export declare abstract class EuropaCore<N, E extends N> {
    private static readonly [_pluginManager];
    private readonly [_environment];
    private readonly [_options];
    /**
     * Creates an instance of {@link EuropaCore} using the `options` provided.
     *
     * @param [options] - The options to be used.
     */
    protected constructor(options: EuropaCoreOptions<N, E>);
    /**
     * Converts the specified `input` into Markdown based on the options configured for this {@link EuropaCore} instance.
     *
     * `input` can either be an HTML string or DOM node(s) to be converted into Markdown.
     *
     * @param input - The HTML string or DOM node(s) to be converted into Markdown.
     * @return The Markdown converted from `input`.
     */
    convert(input: N | N[] | string | null | undefined): string;
    /**
     * Invokes the specified plugin `provider` and registers the resulting plugin.
     *
     * If the plugin contains any converters, they will be associated with their corresponding tag names, overriding any
     * previously converters associated with those tag names.
     *
     * If an error occurs when invoking `provider`, the plugin will not be registered.
     *
     * @param provider - The provider for the plugin to be registered.
     * @throws If a problem occurs while invoking `provider`.
     */
    static registerPlugin(provider: PluginProvider): void;
    /**
     * Invokes the specified plugin `provider` and registers the resulting preset.
     *
     * This method is effectively just a shortcut for calling {@link EuropaCore.registerPlugin} for multiple plugin
     * providers, however, the main benefit is that it supports the concept of presets, which are a useful mechanism for
     * bundling and distributing plugins.
     *
     * If an error occurs when invoking `provider`, the preset and all of its plugins will not be registered.
     *
     * @param provider - The provider for the preset whose plugins are to be registered.
     * @throws If a problem occurs while invoking `provider`.
     */
    static registerPreset(provider: PresetProvider): void;
}
/**
 * The options used by {@link EuropaCore}.
 */
export declare type EuropaCoreOptions<N, E extends N> = {
    /**
     * The environment of the {@link EuropaCore} implementation.
     */
    readonly environment: Environment<N, E>;
    /**
     * The options passed to the {@link EuropaCore} implementation, if any.
     */
    readonly options?: EuropaOptions;
};
export {};
